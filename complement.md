# 补码的设计原理

**补码的设计目的是为了解决有符号数的算术运算**

8位2进制表示的数据为：

    0000 0000|0000 0001|0000 0010|0000 0011|...|1111 1111
 看作无符号数的话，相邻两个数相差1，最后一个数 ***1111 1111***再加1  变为 ***1 0000 0000***，后8位为0，又变成了第一个数，所以就像钟表一样，上面的数据可以看成是一个圈。
 而这步跟 **-1 + 1 = 0** 一致，所以可以把  ***1111 1111*** 看作 ***-1*** 的二进制表示。那么由于 ***1111 1110 + 1 = 1111 1111*** ，那么 ***1111 1110***就
 是 ***-2*** 的二进制表示。以此类推：***1111 1101 = -3*** ，***1111 1100 = -4*** …… ***1000 0000 = -128***。由于有符号数必须要取一位用于表示符号，
 而如上所述，首位 ***1*** 一直没变过，用于表示符号再好不过。而 ***1000 0000*** 再减 ***1*** 就变为 ***0111 111***，首位变化为0，则表示正数。所以8位有符号数
 能表示的范围只能是 ***-128~127***。
 

| ***1111 1101***      | ***1111 1110***      | 1111 1111  |   0000 0000    | 0000 0001|0000 0002|
| --------       | -----:         | :----:         | :----:         | :----:         |:----:         |


如上，分别为：  

    -3，-2，-1，0，1，2  
 
 A + B（A为负数，B为正数）：
 
    -3 + 2 = -1，-2 + 1 = -1，-1 + 0 =- 1 ……  即  A + B = -1
结果都是 ***1111 1111***，

则：

    -B = A + 1 

而进制相加结果为 ***1111 1111*** 则说明两个操作数对应位一定相反，所以：
  
    负数的反码就是绝对值源码的各位取反加一
    
那么B的各位取反的本质就是：
   
    1111 1111 - B 

那么，**源码反码的反码就是源码本身**，因为：

    1111 1111 - (1111 1111 - B + 1) + 1 = B
    
**补码相加的值等于源码相加结果的补码**：

    -A1 + (-A2) = -(A1 + A2) = 1111 1111 - (A1 +A2) + 1
    -A1 + (-A2) = 1111 1111 - A1 + 1 + 1111 1111 - A2 + 1 = 1111 1111 - (A1 + A2) + 1 + 1 0000 0000
    
其中~~1 0000 0000~~在进位中被遗弃。  
因而，补码在数学上完成自洽。

采用补码进行运算A+B时，A、B一正一负，则不会发生溢出。A、B均为正时可能向上溢出，此时最高位由0变为1；A、B均为负时有可能向下溢出，此时最高位由1变为0，补码的运算过程中最高位（第八位）会向更高位（第九位）进一位。
